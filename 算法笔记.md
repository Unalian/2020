

# 算法笔记

参考资料：https://labuladong.gitbook.io/algo/dong-tai-gui-hua-xi-lie/bian-ji-ju-li

## 第一章 动态规划

### 1. 动态规划框架

什么时候用：

* 一般形式就是求最值（**最长**递增子序列呀，**最小**编辑距离）

* 求解动态规划的核心问题是穷举，动态规划问题一般**存在「重叠子问题」**，如果暴力穷举的话效率会极其低下（比如无剪枝递归）
* 具备「最优子结构」，且子问题独立



三要素：重叠子问题、最优子结构、状态转移方程



寻找dp的思路：**明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义**。

```python
# 初始化 base case
dp[0][0][...] = base
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
```



思考框架

1. dp[i]的实际意义
2. 根据已有的dp[i-1]或dp[i-2]推出dp[i] 
3. 思考base case

*如果1.2无法进行，可能是dp的定义出错或者dp的维度不够*



递归和dp的区别：两者都是暴力枚举，但是递归是自顶向下，dp是自底向上

### 2. 动态规划实践：斐波那契数列

#### 1）暴力递归

```C++
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

指数爆炸 o(2^n)

#### 2） 剪枝递归（备忘录）

```c++
int fib(int N) {
    if (N < 1) return 0;
    // 备忘录全初始化为 0
    vector<int> memo(N + 1, 0);
    // 进行带备忘录的递归
    return helper(memo, N);
}

int helper(vector<int>& memo, int n) {
    // base case 
    if (n == 1 || n == 2) return 1;
    // 已经计算过
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

o(n)

#### 3）dp

状态转移：dp[i] = dp[i - 1] + dp[i - 2] basecase: dp[0] = 1, dp[0] = 1 

```C++
int fib(int N) {
    vector<int> dp(N + 1, 0);
    // base case
    dp[1] = dp[2] = 1;
    for (int i = 3; i <= N; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
    return dp[N];
}
```

```c++
//状态压缩：没必要用数组，只需要用两个变量表示dp[i - 1]，dp[i - 2]
int fib(int n) {
    if (n == 2 || n == 1) 
        return 1;
    int prev = 1, curr = 1;
    for (int i = 3; i <= n; i++) {
        int sum = prev + curr;
        prev = curr;
        curr = sum;
    }
    return curr;
}
```

### 3. 动态规划实践 凑零钱问题

给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

#### 1）暴力递归

寻找dp：

1、**确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

2、**确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

3、**确定「选择」，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

4、**明确** **dp** **函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 `dp` 函数：

`dp(n)` 的定义：输入一个目标金额 `n`，返回凑出目标金额 `n` 的最少硬币数量。

```python
def coinChange(coins: List[int], amount: int):

    def dp(n):
        # base case
        if n == 0: return 0
        if n < 0: return -1
        # 求最小值，所以初始化为正无穷
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            # 子问题无解，跳过
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        return res if res != float('INF') else -1

    return dp(amount)
```

#### 2) 剪枝递归

```python
def coinChange(coins: List[int], amount: int):
    # 备忘录
    memo = dict()
    def dp(n):
        # 查备忘录，避免重复计算
        if n in memo: return memo[n]
        # base case
        if n == 0: return 0
        if n < 0: return -1
        res = float('INF')
        for coin in coins:
            subproblem = dp(n - coin)
            if subproblem == -1: continue
            res = min(res, 1 + subproblem)

        # 记入备忘录
        memo[n] = res if res != float('INF') else -1
        return memo[n]

    return dp(amount)
```

#### 3) dp

现在使用自底向上的dp迭代算法解决问题

dp数组：**当目标金额为** **i** **时，至少需要** **dp[i]** **枚硬币凑出**。

转移方程：dp[i] = min(dp[i], 1 + dp[i - coin]);

遍历i，每个i遍历coin可能值，得出最小的dp[i]

```C{{
int coinChange(vector<int>& coins, int amount) {
    // 数组大小为 amount + 1，初始值也为 amount + 1
    vector<int> dp(amount + 1, amount + 1);
    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.size(); i++) {
        // 内层 for 循环在求所有选择的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) continue;
            dp[i] = min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount]
```

```python
## 322
class scr_change:
    def solution(self, amount, coins):
        dp = [amount + 1]*(amount+1)
        dp[0] = 0
        for i in range(1,amount+1):
            for coin in coins:
                if i  < coin:
                    continue
                dp[i] = min(dp[i - coin]+1, dp[i])
        if dp[amount] == amount + 1: return -1
        return dp[amount]

a = scr_change
print(a.solution(a,2, [3]))
```

### 4. 动态规划实践 最长递增子序列

Given an unsorted array of integers, find the length of longest increasing subsequence.

**Example:**

```
Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
```

**Note:** 

- There may be more than one LIS combination, it is only necessary for you to return the length.
- Your algorithm should run in O(***n^2***) complexity.

**Follow up:** Could you improve it to O(*n* log *n*) time complexity?



这道题三种解法，在这里只说复杂度n^2的dp解法，二分法学完二分法再说。



1. dp[i] : 以i结尾的最长递增子序列长度 

2. dp[i] = max(dp[j]+1,dp[i])

   dp[j]是在i之前，dp[j]<dp[i]

```python
class Solution(object):
    def lengthOfLIS(self, nums):
        bp = [1]* len(nums)
        res = 0
        for i in range(0,len(nums)):
            for j in range(0,i):
                if nums[i] > nums[j]:
                    bp[i] = max(bp[j]+1, bp[i])
        for item in bp:
            res = max(item, res)
        return res
```



